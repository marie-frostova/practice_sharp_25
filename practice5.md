Для сдачи заданий этого блока заведите в проекте App директорию Practice5. Допускается, чтобы все задания были в одной ветке (pull request) на гите.

# Предисловие

Так как мы занимаеся разработкой лучшего маркетплейса в Мультивселенной, нам нужно, чтобы главная страница загружалась со световой скоростью. На главной странице находится каталог трендовых товаров. 
Внутри приложения есть несколько типов операций с товарами:

	- товары загружаются из базы данных в массив,
	- товары в массиве передаются между внутренними методами. 
	
Используя свои знания о структурах и классах, попробуйте предсказать, как лучше организовать хранение продуктов: в виде классов или структур, чтобы маркетплейс работал быстрее?

А чтобы не быть голословным перед коллегами, вы решили доказать состоятельность своей гипотезы наглядным экспериментом. В этом эксперименте, вы сравните производительность операций создания массивов классов/структур и передачи их в методы.

Скачайте проект, который находится в [этом](https://github.com/marie-frostova/experiments/tree/master) репозитории.
Несмотря на то, что задание вы будете выполнять в новом проекте, сдавать домашку надо в вашем старом репозитории, скопировав содержимое папки Practice5.

# Задание 1

Сперва напишем заглушку с рандомными данными, чтобы убедиться в корректной работе графиков.
Обратите внимание на класс `ChartDataGenerator`.
В нем есть метод `GenerateRandomChartData`, который использует метод `GenerateExperimentResults`.

Вам необходимо реализовать класс `RandomExtensions` в соответсвующем файле папки Practice5. В нем необходимо сделать 2 метода расширения: 
- `int NextInclusive` - принимает `int min, int max`
- `double NextDoubleInclusive` - принимает `double min, double max`.
Оба генерируют случайное число нужного типа в диапазоне от `min` до `max` включительно.

Теперь нужно воспользоваться методами расширения для того, чтобы поправить метод `GenerateExperimentResults`, чтобы он выдавал действительно рандомные данные.

Теперь при запуске проекта у вас должны генерироваться данные при выборе опции Random Data.

# Задание 2

## Часть 1

Теперь создадим вспомогательный код для бенчмаркинга - так называется измерение производительности отдельных участков кода.

В файле `BenchmarkTask.cs` реализуйте в классе `Benchmark` интерфейс `IBenchmark`. Подробности ниже.

Интерфейс `IBenchmark` содержит единственный метод, принимающий `task` — действие, скорость работы которого нужно измерить. И возвращает длительность в миллисекундах.

```csharp
double MeasureDurationInMs(ITask task, ...)
```

В этот метод можно посылать любую реализацию простейшего интерфейса `ITask`:

```csharp
public interface ITask
{
    void Run();
}
```

Измерить длительность выполнения `Run` в методе `MeasureDurationInMs` можно с помощью класса `Stopwatch`. Однако важно учитывать ряд тонкостей бенчмаркинга:

1. Современные компьютеры умеют измерять время лишь с некоторой точностью. Поэтому измерять время выполнения одной очень короткой операции бессмысленно. Нужно повторить ее множество раз, засечь суммарное время и поделить результат на количество повторений. Для этого метод `MeasureDurationInMs` принимает вторым аргументом `repetitionCount` — количество повторений.
2. Среда исполнения .NET компилирует отдельные методы в машинный код только тогда, когда он понадобился первый раз. Этот подход называется JIT — just in time compilation. Как следствие, первый вызов метода может быть значительно медленнее последующих. Поэтому перед измерением времени нужно сделать один "прогревочный" вызов.
3. Проект собирается в режиме отладки (Debug) или в режиме релиза (Release). В режиме отладки компилятор не применяет оптимизации кода, что негативно сказывается на производительности. Поэтому перед запуском тестов на производительность [переключите сборку проекта в релиз](https://docs.microsoft.com/ru-ru/visualstudio/debugger/how-to-set-debug-and-release-configurations?view=vs-2019).
4. В произвольный момент времени выполнение программы может быть приостановлено сборщиком мусора. Это тоже негативно влияет на точность измерений. Минимизировать вероятность этого можно, вызвав сборщик мусора принудительно перед тем, как начинать засекать время. Это можно сделать так:

```csharp
GC.Collect();
GC.WaitForPendingFinalizers();
```

Кроме того, имейте в виду, что современные компьютеры имеют режим энергосбережения. В таком режиме частота его процессора может быть искусственно понижена и результаты всех замеров производительности могут стать непредсказуемыми. Ноутбуки могут иногда автоматически включать этот режим, например, когда они отключены от сети или когда остается мало заряда батареи.

Теперь у вас достаточно информации, чтобы реализовать Benchmark в файле `BenchmarkTask.cs`.

## Часть 2

Пора как-нибудь применить ваш Benchmark. Например, сравнив производительность каких-нибудь двух способов сделать одно и то же.

Напишите в том же файле unit-тест в методе `StringConstructorFasterThanStringBuilder`. В нем нужно сравнить два способа создания строки, состоящей из 10000 букв `'а'`:

1. Создать `StringBuilder`, много раз вызвать `Append`, а в конце вызвать у него `ToString()`.
2. Вызвать специализированный конструктор строки `new string('a', 10000)`.

Постарайтесь выбрать количество повторений так, чтобы суммарно весь этот тест работал около секунды, чтобы нивелировать описанные выше эффекты.

Тест должен с помощью `Assert.Less` проверять, что специализированный конструктор строки работает быстрее, чем `StringBuilder`.

Для каждого метода создания строки создайте свою реализацию `ITask` в том же файле. Используйте их совместно с классом `Benchmark` в тесте, чтобы сравнить время работы.

# Задание 3

Пришло время делать эксперименты. Продолжайте в том же проекте, в файле ExperimentsTask.cs
## Часть 1

В файле ArrayCreationTasks.cs есть две реализации уже знакомого вам интерфейса `ITask` для работы с классом `Benchmark`. Оба класса создают массив в методе `Run`. Но один делает массив структур, а второй массив классов.

В классе `ExperimentsTask` реализуйте метод `BuildChartDataForArrayCreation`. Этот метод должен измерять длительность работы метода `Run` у классов `StructArrayCreationTask` и `ClassArrayCreationTask` с помощью `Benchmark` из прошлого задания.

Нужно измерить время для структур и классов всех размеров, указанных в `Constants.FieldCounts`. Результаты измерения вернуть в виде объекта `ChartData`. Дальше в Program.cs эти результаты будут показаны на графиках.

Запустите код на исполнение, выберите опцию Array Creation. Вы должны увидеть первый график скорости работы от количества полей в классе/структуре. На нем должно быть видно, что массивы классов создаются дольше, чем массивы структур.

## Часть 2

Аналогично в файле MethodCallTasks.cs есть еще пара реализаций `ITask`. Они вызывают метод, передавая в качестве аргумента класс или структуру с большим количеством полей.

В том же классе `ExperimentsTask` реализуйте метод `BuildChartDataForMethodCall`.

Избавьтесь от дублирования кода в методах `BuildChartDataForMethodCall` и `BuildChartDataForArrayCreation`. Возможно, для этого понадобится создать новые классы.

Запустите код на исполнение. Вы должны увидеть второй график, показывающий, что большие классы передаются в метод быстрее, чем большие структуры.

Попробуйте объяснить наблюдаемый результат.
