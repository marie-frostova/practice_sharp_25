## Задание 1.

"Полигоны - перспективная тема!" - с таким высказыванием в отдел разработки маркетплейса забежал дизайнер. Его задумка достаточно простая - вместо использования растровых изображений, которые занимают много места в памяти, он хочет перейти на использование векторных изображений. Для реализации такого перехода необходимо научить движок маркетплейса работать с различными полигонами, пока простейшими: треугольник, прямоугольник, квадрат.

Итак, вы собрали функциональные требования от дизайнера и перевели их в соответствующие интерфейсы.

```c#
public interface I2DVertex
{
    double X { get; set; }
    double Y { get; set; }
}
```

```c#
public interface IGeometry
{
    double CalculateArea();
    int VertexCount { get; }
}
```

Дело за малым: осталось реализовать эти интерфейсы для трех типов полигонов - треугольник, прямоугольник, квадрат. А также для каждого типа полигона написать тесты на соответствующие методы расчета.

Подсказка: в математике считается, что квадрат является частным случаем прямоугольника.

## Задание 2.

Со стороны заказчика-дизайнера, который мотивировал вас заводить полигоны для векторной графики, появились дополнительные требования. Требования следующие: 
- нужно, чтобы точки могли сортироваться между собой против часовой стрелки. Подсказка: для этого изучите интерфейс `IComparer` и реализуйте класс `ClockwiseComparer`, чтобы можно было в коде использовать для сортировки `Array.Sort(array, new ClockwiseComparer());`
- каждая точка умела в методе `ToString` выдавать информацию о себе в виде `"(x = ?.???, y = ?.???)"`, где после запятой будет точность в три знака (даже если это `000`). Подсказка: изучите документацию к методу `ToString` у типа `double`.
- нужно реализовать функцию `string LogGeometry(IGeometry geometry)` в классе `Logger`, которая будет возвращать: "треугольник", "прямоугольник", "квадрат" или "неизвестная геометрия" в зависимости от того, что за геометрию передали в метод.

## Задание 3.

На очередном инженерном штурме по рефакторингу архитектуры, была задета тема работы с пользователи. Выделили следующую структуру:

- User (см. задание 3):
	- Employee
		- `List<Order>`
		- `inn` (юр. лица)
	- Customer
		- `Cart`
		- `List<Order>`
	- Admin
		- `List<Employee>`
	- Seller
		- `List<Product>`
		- `List<Order>`
		- `inn` (юр. лица)
		
Реализуйте классы-наследники `User`-а: `Employee`, `Customer`, `Admin`, `Seller`, а также вспомогательные классы-заглушки: `Order`, `Cart`, `Product`. 
		
Работа с сущностями обычно осуществляется с помощью объекта `<Domain>Service`. Соответственно в случае работы с пользователями, реализовывать будем `IUsersService` и его наследника `UsersService`. 

Реализуйте код класса `UsersService`, и кроме самой реализации, напишите тесты. Один из тестов, например, проверка сценария: создание пользователя -> обновление пользователя -> удаление пользователя. Или, может, что после смены пароля, нельзя залогиниться по старому паролю.

Код интерфейса:
```c#
public interface IUsersService
{
	User GetUser(Guid userId);
	Guid CreateUser(CreateUserDto createUserDto);
	void DeleteUser(Guid userId);
	void ChangePassword(Guid userId, string oldPassword, string newPassword);
	void UpdateUser(Guid userId, UpdateUserDto updateUserDto);
	
	Guid LogIn(string login, string password);
}
```

Вспомогательные классы:
```c#
public sealed class CreateUserDto
{
    public string Login { get; init; }
    public string Password { get; init; }
    public string Name { get; init; }
    public string Surname { get; init; }
    public string Inn { get; init; }
    public string Phone { get; init; }
}

public sealed class UpdateUserDto
{
    public string Name { get; init; }
    public string Surname { get; init; }
    public string Inn { get; init; }
    public string Phone { get; init; }
}

```

Подсказка: не все поля вспомогательных классов могут быть заполнены, следует осуществлять проверку на `null`.

Подсказка: если что-то идет не так, например, пароль неверный или удаляем несуществующего пользователя или какие-то другие исключительные ситуации, то выкидывайте исключение `Exception(<поясняющее сообщение>)`.

Подсказка: очень нежелательно хранить пароли пользователя в открытом виде, лучше использовать алгоритмы хеширования.
